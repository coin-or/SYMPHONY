SYMPHONY Version 4.0 README
===========================

Welcome to SYMPHONY. SYMPHONY is distributed under the Common Public License
Version 1.0 and is freely redistributable. However, it is vital to the
survival of projects such as this one that we be able to justify our existence
through usage statistics. Therefore, we ask that you become a registered user
of this software if you have not already. Registration is free, but helps us
maintain our funding. Please visit SYMPHONY's registration page at
http://branchandcut.org/SYMPHONY/license.htm to receive an official copy of
the distribution. All source code and documentation is Copyright 2000-2003 by
Ted Ralphs. This README may be distributed freely.

DOCUMENTATION
=============

Full documentation comes with your distribution in the directory
SYMPHONY-4.0/Doc and can also be downloaded at
ftp://branchandcut.org/pub/reference/. There is a user's guide
(SYMPHONY-4.0-Manual.pdf) that should be read prior to developing an
application.

WHAT'S NEW
==========

There has been a significant amount on new development over the last few
months that we hope will make version 4.0 significantly easier to use, as well
as significantly more powerful. Unfortunately, this also means that there have
been a number of changes to the API. Code written for previous versions of
SYMPHONY will be broken and will have to be ported. All this change has also
undoubtedly introduced bugs. There are now a VERY large number of
configurations in which SYMPHONY can be used and we have tested many of them,
but it is not possible to test them all. Please keep this is mind and report
all bugs that you find.

1. All reported bugs have been fixed. A few memory leaks have also been
eradicated. 

2. SYMPHONY now works out of the box as a full-featured, parallel MIP solver,
with a wide variety of options for developing custom solvers.

3. SYMPHONY now makes full use of the libraries available from COIN
(www.coin-or.org) for cut generation, file I/O, and solver interface.

    a. SYMPHONY is now capable of reading both MPS files (through the COIN MPS
reader) and basic AMPL files (using the parser available from GLPK).

    b. SYMPHONY now uses the COIN Open Solver Interface (OSI), allowing it to
be used with almost any commonly available LP solver, including a number of
open source solbers. This makes SYMPHONY an end-to-end open source solution.

    c. SYMPHONY can now use COIN's Cut Generator Library (CGL) to generate
generic cutting planes.

4. The API has been simplified SIGNIFICANTLY, with more default options,
helper functions, and more autmation of basic functions. The parallelism is
now more hidden, especially for sequential users.

5. There is now automated support for user cuts generated and stored as
explicit matrix rows. The user no longer has to derive a packed form and does
not have to implement user_unpack_cuts() in order to use cuts expressed as
explicit matrix rows.

6. Improvements have been made to the mechanism for accessing and displaying
solutions.

7. There is now built-in support for column names.

8. More sample codes are now available, including solvers for vehicle routing,
set partitioning (basic and advaced versions), bipartite matching, and the
mixed postman problem.

9. Improvements to the makefile now allow the user to make the code from the 
User directory instead of the SYMPHONY directory. Also, executables can have
custom names and are built in different directories for different LP solvers
so the object files don't have to be cleaned to switch LP solvers.

10. There is now a white paper available that illustrates the use of SYMPHONY
to build a simple matching solver.

CHANGES TO THE USER INTERFACE
=============================

I'm sorry to say that there are quite a few changes to the user interface. Code 
written for previous versions of SYMPHONY will be broken, but not too
badly. Here is a quick guide to the changes.  

1. Return codes for user functions have changed in order to avoid conflict
with SYMBOLS defined in the many solvers SYMPHONY can now link with. Old
return codes are appended with the prefix "USER_". Also, optional
post-processing has been eliminated, so the old return codes "USER_NO_PP" and
"USER_AND_PP" have been combined into a single return code "USER_SUCCESS" to
indicate that the user function was executed successfully. 

2. Make files are set up a bit differently. The user make file is now thw
driver. Some variables that used to be set in \texttt{SYMPHONY/Makefile} must
now be set in the user's make file. See the file
\texttt{SYMPHONY/USER/Makefile} for an example of what the user's make file is
now supposed to look like. 

3. The mechanism for diplaying a solution is now vastly improved. 
SYMPHONY now passes the user the indices and values of the nonzero
variables for the best solution found. The function user_display_solution()
now has six arguments, as follows:  

int user_display_solution (void *user, double lpetol, int varnum,
			   int *indices, double *values, double objval);

user:    The pointer to the user data structure (as usual).
lpetol:  The LP zero tolerance used.
varnum:  The number of nonzeros in the solution.
indices: The indices of the nonzeros.
values:  The values of the nonzeros.
objval:  The objective function value of the solution.

The user can interpret the solution and print it out in a custom format or
simply return "DEFAULT", in which case the solution will be displayed by
SYMPHONY as a column of indices and values.

4. The functions user_readparams() and user_io() now have default
implementations that simply read in an MPS whose file name is given on the
command line (see the file SYMPHONY-4.0/USER/README-1.0 for a
description). These functions no longer have to be modified by the user when
using SYMPHONY as a generic MIP solver.

5. Replaced user_set_base() and user_create_root() with a single function
called user_initialize_root_node(), in which the user simply has to specify
the list of base and extra variables. This is greatly simplified from previous
versions.

6. Changed the name of user_create_lp() function to user_create_subproblem()
to more accurately reflect its actual function. In addition, the interface to
the user has been simplified significantly. The user now has only to construct
a description of the subproblem by specifying the constraint matrix in
column-ordered format and the rim vectors, along with a list of which
variables are required to be integer. The user is no longer responsible for
allocating extra memory to allow for the addition of dynamically generated
cuts and variables. The arrays allocated in user_create_subproblem() are owned
by SYMPHONY after allocation and are freed as soon as the relaxation is loaded
into the solver.

7. Eliminated the user_get_upper_bounds(). The bounds are now set in either
user_create_subproblem() and user_generate_column().

8. Simplified the interface for user_generate_cuts_in_lp(). The user now gets
access to the data structures for the current LP relaxation and has
only to return a list of cuts. The cuts are unpacked and added by
SYMPHONY. The new interface is as follows:

int user_generate_cuts_in_lp PROTO((void *user, LPdata *lp_data, int varnum,
				    var_desc **vars, double *x, int *new_row_num,
				    cut_data ***cuts));

******************************************************************************
*                COMPILING SYMPHONY (UNIX Operating Systems)                 *
******************************************************************************

Here is a sketch outline of how to get started with SYMPHONY in Unix. These
instructions will lead you through the steps required to compile SYMPHONY as a
generic MIP solver that can then be customized by filling out the functions
provided in the user interface files. For information on customizing SYMPHONY
to obtain a custom solver, a quick start guide is provided below and more
detailed information is available in the user's manual. Because SYMPHONY is
intended to run over nonhomogeneous networks of workstations, installation is
not fully automated, but requires the user to make minor edits to the
Makefile.  With this setup, compilation for multiple architectures and
configurations can be performed in a single directory without reconfiguring or
"cleaning". This is convenient on nonhomogeneous networks, but it means that
you might need to edit the Makefiles to get SYMPHONY to compile. For the casual
user, this editing is limited to providing some path names.

PREPARING FOR COMPILATION
=========================

1. Download the file SYMPHONY-4.0.tgz.

2. Unpack the distribution with "tar -xzf SYMPHONY-4.0.tgz". This will
create a subdirectory called SYMPHONY-4.0/ containing the distribution.

3. Edit the the Makefile (SYMPHONY-4.0/Makefile) to reflect your
environment. This involves specifying the LP solver to be used and the paths
to various libraries and include files. Only minor edits should be
required. An explanation of what has to be set is contained in the comments in
the Makefile.

4. To use many of the new capabilities of SYMPHONY, you must have installed
the COIN libraries, available from www.coin-or.org. Specifically, you should
install OSI, CGL, and the Coin utilities (in the COIN/Coin directory). If you
want to use the COIN LP solver, you should also download CLP. These can be
downloaded from www.coin-or.org. The path to the COIN libraries must be
specified in SYMPHONY-4.0/Makefile.

5. If you wish to read AMPL files, you will have to install the Gnu Linear
Programming Kit (GLPK), which contains a parser for AMPL files. The path to
the COIN libraries must be specified in SYMPHONY-4.0/Makefile.

COMPILING THE SEQUENTIAL VERSION
================================

1. Change to the SYMPHONY-4.0/USER directory and type "make". This will first make
the SYMPHONY library (sequential version). After making the SYMPHONY library,
make will compile the user customization library and link the executable. The
name of the executable is specified in the file SYMPHONY-4.0/USER/Makefile and is
"mip" by default. The executable is installed in the directory
SYMPHONY-4.0/USER/bin.$(ARCH)/$(LP_SOLVER), where ARCH is the current architecture
and LPSOLVER is the current LP solver, as specified in the makefile. The
makefile must be modified to enable parallel execution of the code (see
below).

2. After the SYMPHONY library is compiled, you are free to type "make clean"
and/or delete the directories SYMPHONY-4.0/obj.* and SYMPHONY-4.0/dep.* if you
want to save disk space. You should only have to remake the SYMPHONY library
if you change something in SYMPHONY's internal files. To clean the user files,
type "make clean_user".

3. To test SYMPHONY, a sample MPS file called test.mps is included with the
distribution. To specify the file name, use the "-F" command-line option,
i.e., type "bin.$(ARCH)/$(LP_SOLVER)/mip -F test.mps" in the SYMPHONY-4.0/USER
directory. To obtain more MPS data files for further testing, download the
MIPLIB library. 

4. That's it! Now you are ready to develop your own application by modifying
the files in the MIP directory and it's subdirectories.

COMPILING FOR SHARED MEMORY
===========================

1. To compile a shared memory version, obtain an OpenMP compliant compiler,
such as Omni (free from http://phase.etl.go.jp/Omni). Other options are listed
at http://www.openmp.org.

2. Follow the instructions above for configuring the makefile. Set the
variable CC to the compiler name in the Makefile and compile as above. Note
that if you have previously compiled the sequential version, then you should
first type "make clean_all", as this version uses the same directories. With
one thread allowed, it should run exactly the same as the sequential version
so there is no need to compile both versions.

3. Voila, you have a shared memory parallel solver! As above, test symphony,
using the sample MPS file called test.mps included with the distribution. To
specify the file name, use the "-F" command-line option, i.e., type
"bin.$(ARCH)/$(LP_SOLVER)/mip -F test.mps" in the SYMPHONY-4.0/USER directory. To
obtain more MPS data files for further testing, download the MIPLIB library.

4. That's it! Now you are ready to develop your own application by modifying
the files in the SYMPHONY-4.0/USER directory and it's subdirectories. See the
user manual for help.

COMPILING FOR DISTRIBUTED NETWORKS
==================================

1. If you wish to compile a distributed version of the code, obtain and
install PVM from http://www.csm.ornl.gov/pvm/.

2. In the Makefile, be sure to set the COMM_PROTOCOL variable to "PVM". Also,
change one or more of COMPILE_IN_TM, COMPILE_IN_LP, COMPILE_IN_CG, and
COMPILE_IN_CP, to FALSE, or you will end up with the sequential version.
Various combinations of these variables will give you different configurations
and different executables. See the manual for more information on setting
them. Also, be sure to set the path variables in the Makefile appropriately so
that make can find the PVM library.

3. As above, type "make" in the SYMPHONY-4.0/USER directory to make the
distributed libraries. As in Step 1 of the sequential version, you may type
"make clean" after making the library. It should not have to remade again
unless you modify SYMPHONY's internal files.

4. After the SYMPHONY libraries, user code will be compiled and required
executables linked.

5. Make sure there are links from your $PVM_ROOT/bin/$PVM_ARCH/ directory to
each of the executables in your SYMPHONY-4.0/USER/bin.$(ARCH)/$(LP_SOLVER)
directory. This is required by PVM.

6. Start the PVM daemon by typing "pvm" on the command line and then typing
"quit".

7. As above, test SYMPHONY using the sample MPS file called test.mps included
with the distribution. To specify the file name, use the "-F" command-line
option, i.e., type "bin.$(ARCH)/$(LP_SOLVER)/mip -F test.mps" in the
SYMPHONY-4.0/USER directory. To obtain more MPS data files for further testing,
download the MIPLIB library.

8. That's it! Now you are ready to develop your own application by modifying
the files in the MIP directory and it's subdirectories. See the user manual
for help.

*******************************************************************************
*                 COMPILING SYMPHONY (Microsoft Windows)                      *
*******************************************************************************

Here is a sketch outline of how to compile SYMPHONY in Microsoft Windows. For
information on developing your own applications, please see the quick start
guide below or the detailed explanation in the user's manual. Direct support
is provided for compilation under MS Visual Studio 6.0. Compilation for other
compilers should also be possible. Note that the Windows version has some
limitations. Detailed timing information is not currently provided.  Support
is only provided for running in sequential mode at this time.

1. Download SYMPHONY-4.0.zip and unzip the archive. This will create a
subdirectory called SYMPHONY-4.0/ containing all the source files.

2. In MS Visual C++ 6.0, open the workspace SYMPHONY-4.0/USER/WIN32/user.dsw.
Note that there are two projects, one called "symphony" and one called "user".
The symphony project compiles the source of the internal library. The user
project compiles a separate library containing the user-defined functions
that can be used to customize the solver. 

3. To use many of the new capabilities of SYMPHONY, you must have installed
the COIN libraries. Specifically, you should install OSI, CGL, and the Coin
utilities (in the COIN/Coin cirectory). If you want to use the COIN LP solver,
you should also download CLP. These can be downloaded from www.coin-or.org.

3. By default, SYMPHONY is set up to use the OSI CPLEX interface with the COIN
libraries installed in a folder called C:\COIN and CPLEX installed in a folder
called "C:\ILOG\CPLEX81". To use a different LP solver or to specify a
different location for OSI or CPLEX, there are a number of changes that need
to be made.

  --You must specify the names of and paths to the library to be linked. Do
this by right-clicking on the symphony project and choosing "Add Files to
Project..." Then locate the library file for the LP solver you are using, as
well as the OSI library (if you are using OSI). If you switch, make sure to
delete the old library dependency.

  --You must set the include path for the solver header files. Do this by
right-clicking on the symphony project and choosing "Settings..." Then choose
the "C/C++" tab, and choose the category "Preprocessor" on the drop-down menu.
Edit the path in the "Additional include directories" window.

  --You must set the compiler defines so that the right LP solver interface
will be used. Follow the procedure above to get to the preprocessor settings
and edit the "Preprocessor definitions". Make sure that __OSL__ is defined if
you are using OSL or __CPLEX__ is defined if you are using CPLEX. If you are
using OSI, then the proper define is __OSI_xxx__, where "xxx" specifies the
desired solver. For example, to specify OSL with the OSI interface, the proper
define is __OSI_OSL__.  DO NOT CHANGE COMPILER DEFINES NOT RELATED TO THE LP
SOLVER. Important note for OSL users: When using OSL in Windows, you must also
add "OSLMSDLL" to the list of definitions.

4. By default, SYMPHONY is also set up to use the COIN CGL library for
generating cuts. If you have not installed CGL, delete the define ADD_CGL_CUTS
from the list.

5. Note that there are a number of additional preprocessor definitions that
control the functionality of SYMPHONY. These definitions are described in
SYMPHONY-4.0/Makefile, a Unix-style makefile included with the
distribution. To enable the functionality associated with a particular
definition, simply add it to the list of definitions, as above.

6. You must also be sure to have any .dll files required for your LP solver to
be in your search path. Either move the required .dll to the directory
containing symphony.exe or add the path to the "PATH" Windows environment
variable.

7. Once you have the proper settings for your LP solver, choose "Build
symphony.exe" from the Build menu. This should successfully build the
executable.

8. To test the executable, right click on the symphony project, go to the
"Debug" tab and set the program arguments to "-F test.mps"
Note that command-line switches are Unix-style.

8. Now choose "Execute" from the build menu and the solver should solve the
sample problem.

9. Note that there is some functionality missing from the Windows
version. Most prominently, the timing functions do not work. I suppose this
functionality should be easy to add -- let me know if you are interested in
doing it and I will give you all the help I can. In addition, the Windows
version will only run in sequential mode for a variety of reasons. However, it
should be relatively easy to get it running in parallel if you can get PVM
working under Windows. Let me know if you are interested.

*******************************************************************************
*                 QUICK START DEVELOPMENT GUIDE (UNIX)                        *
*******************************************************************************

Developing a simple branch and bound solver that can read in instance data in
a custom format is straightforward using the template provided in the
SYMPHONY-4.0/USER/ directory. The simplest approach is to develop a sequential
application, sharing a single user data structure among all the modules. Using
this approach, an application can be developed by filling in only a few simple
functions. Here are some steps to make the most common custom modifications.

1. Decide what run-time parameters you might need and what data has to
be stored to describe your instance. Edit the file USER/include/user.h,
adding the appropriate fields to the user_parameter and user_problem
structures to store the relevant values.

2. Now edit the file USER/Master/user_master.c. Only two function needs to be
filled out initially in order to read in . The function user_io() is where you
can read in the instance data, if it is in something other than MPS format (a
TSPLIB file, for example. Note that the name of the file to read the instance
data from can be specified on the command line using the "-F" option by
default. Also, you'll probably need to modify the user_initialize_root_node()
function to set up the root node.

3. Edit the file USER/LP/user_lp.c. The function user_create_subproblem() must
be filled out. This is the most important function, as it sets up the initial
LP relaxation in each search node.

4. You may also want to add some problem-specific cutting planes by modifying
the user_find_cuts() function.

Now compile by typing "make" again and that's it! You should now have a
working branch and bound solver. Next you can work on filling in more advanced
functions and adding cutting planes. See the documentation for more
information on this.

*******************************************************************************
*               QUICK START DEVELOPMENT GUIDE (Microsoft Windows)             *
*******************************************************************************

Developing a simple branch and bound solver that can read in instance data in
a custom format is straightforward using the template provided in the
SYMPHONY-4.0\USER\ directory. The simplest approach is to develop a sequential
application, sharing a single user data structure among all the modules. Using
this approach, an application can be developed by filling in only a few simple
functions. Here are some steps to make the most common custom modifications.

1. Decide what run-time parameters you might need and what data has to
be stored to describe your instance. Edit the file USER\include\user.h,
adding the appropriate fields to the user_parameter and user_problem
structures to store the relevant values.

2. Now edit the file SYMPHONY-4.0/USER\Master\user_master.c. Only two function
needs to be filled out initially in order to read in . The function user_io()
is where you can read in the instance data, if it is in something other than
MPS format (a TSPLIB file, for example. Note that the name of the file to read
the instance data from can be specified on the command line using the "-F"
option by default. Also, you'll probably need to modify the
user_initialize_root_node() function to set up the root node.

3. Edit the file USER\LP\user_lp.c. The function user_create_subproblem() must
be filled out. This is the most important function, as it sets up the initial
LP relaxation in each search node.

4. You may also want to add some problem-specific cutting planes by modifying
the user_find_cuts() function.

Now build again and you have a working branch and bound solver! Next you can
work on filling in more advanced functions and adding cutting planes. See the
documentation for more information on this.

*******************************************************************************
*                           SAMPLE APPLICATIONS                               *
*******************************************************************************

There are now a number of sample applications available as examples of how
to do development with SYMPHONY. These include solvers for the matching
problem, the set partitioning problem (simple and advanced versions), the 
vehicle routing and traveling salesman problems, and the mixed postman
problem. These applications are distributed as separate packages and can be
downloaded from www.branchandcut.org. There is a white paper that guides the
user through the development of the matching solver.

LIST SERVE

There is a list serve for SYMPHONY users. To subscribe, send a message
containing "subscribe symphony-users" to majordomo@branchandcut.org.

AUTHORS

SYMPHONY was jointly developed by Ted Ralphs (tkralphs@lehigh.edu) and Laci
Ladanyi (ladanyi@us.ibm.com). Menal Guzelsoy (megb@lehigh.edu) helped with
development and debugging of SYMPHONY 4.0.

BUG REPORTS

Bug reports should be sent to symphony-bugs@branchandcut.org.

