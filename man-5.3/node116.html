<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Case Study: Implementing a Matching Solver</TITLE>
<META NAME="description" CONTENT="Case Study: Implementing a Matching Solver">
<META NAME="keywords" CONTENT="man">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="man.css">

<LINK REL="previous" HREF="node110.html">
<LINK REL="up" HREF="node97.html">
<LINK REL="next" HREF="node117.html">
</HEAD>

<BODY >

<DIV CLASS="navigation">
<A NAME="tex2html1970"
  HREF="node117.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1966"
  HREF="node97.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1962"
  HREF="node115.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1968"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>   <A HREF=http://projects.coin-or.org/SYMPHONY>Back to SYMPHONY Home Page</A>
<BR>
<B> Next:</B> <A NAME="tex2html1971"
  HREF="node117.html">Reference</A>
<B>Up:</B> <A NAME="tex2html1967"
  HREF="node97.html">Developing Custom Applications</A>
<B> Previous:</B> <A NAME="tex2html1963"
  HREF="node115.html">Other Debugging Techniques</A>
<BR> <P>
</DIV>
<!--End of Navigation Panel-->

<H1><A NAME="SECTION00670000000000000000">
Case Study: Implementing a Matching Solver</A>
</H1>

<P>
This section was contributed by Michael Trick a few years ago and is a
walkthrough of the steps for developing a very simple application using
SYMPHONY. Rather than presenting the code in its final version, we will go
through the steps that a user would go through. Note that some of the code is
lifted from the vehicle routing application. This code is designed to be a
sequential code. The MATCH application discussed here is part of the SYMPHONY
distribution and the source code can be found in the

<FONT COLOR="#a52a2a"><TT>SYMPHONY/Applications/MATCH</TT></FONT> directory.

<P>
The goal is to create a minimum matching on a complete graph. Initially, we
will just formulate this as an integer program with one variable for each
possible pair that can be matched. Then we will include a set of constraints
that can be added by cut generation.

<P>
We begin with the template code in the 
<FONT COLOR="#a52a2a"><TT>USER</TT></FONT> subdirectory included with
SYMPHONY. This gives stubs for each user callback routine. First, I need to
define a data structure for describing an instance of the matching problem. We
use the template structure 
<FONT COLOR="#a52a2a"><TT>USER_PROBLEM</TT></FONT> in the file

<FONT COLOR="#a52a2a"><TT>include/user.h</TT></FONT> for this purpose.  To describe an instance, we just
need the number of nodes and the cost matrix. In addition, we also need a way
of assigning an index to each possible assignment. Here is the data
structure: 

<PRE>
typedef struct USER_PROBLEM{
   int              numnodes;
   int              cost[MAXNODES][MAXNODES];
   int              match1[MAXNODES*(MAXNODES-1)/2];
   int              match2[MAXNODES*(MAXNODES-1)/2]; 
   int              index[MAXNODES][MAXNODES];
}user_problem;
</PRE>
The fields 
<FONT COLOR="#a52a2a"><TT>match1</TT></FONT>, 
<FONT COLOR="#a52a2a"><TT>match2</TT></FONT>, and

<FONT COLOR="#a52a2a"><TT>index</TT></FONT> will be used later in the code in order to map variables to the
corresponding assignment and vice versa. 

<P>
Next, we need to read in the problem instance. We could implement this
function within the 
<FONT COLOR="#a52a2a"><TT>user_io()</TT></FONT> callback function (see the file

<FONT COLOR="#a52a2a"><TT>user_master.c</TT></FONT>). However, in order to show how it can be done
explicitly, we will define our own function 
<FONT COLOR="#a52a2a"><TT>match_read_data()</TT></FONT> in

<FONT COLOR="#a52a2a"><TT>user_main.c</TT></FONT> to fill in the user data structure and then use

<FONT COLOR="#a52a2a"><TT>sym_set_user_data()</TT></FONT> to pass this structure to SYMPHONY. The
template code already provides basic command-line options for the user. The
``-F'' flag is used to specify the location of a data file, from which we will
read in the data. The datafile contains first the number of nodes in the graph
(
<FONT COLOR="#a52a2a"><TT>nnodes</TT></FONT>) followed by the pairwise cost matrix (nnode by nnode). We
read the file in with the 
<FONT COLOR="#a52a2a"><TT>match_read_data()</TT></FONT> routine in

<FONT COLOR="#a52a2a"><TT>user_main.c</TT></FONT>:

<P>

<PRE>
int match_read_data(user_problem *prob, char *infile)
{
   int i, j;
   FILE *f = NULL;

   if ((f = fopen(infile, "r")) == NULL){
      printf("main(): user file %s can't be opened\n", infile);
      return(ERROR__USER); 
   }

   /* Read in the costs */
   fscanf(f,"%d",&amp;(prob-&gt;numnodes));
   for (i = 0; i &lt; prob-&gt;numnodes; i++)
      for (j = 0; j &lt; prob-&gt;numnodes; j++)
         fscanf(f, "%d", &amp;(prob-&gt;cost[i][j]));
   
   return (FUNCTION_TERMINATED_NORMALLY);
}
</PRE>   

<P>
We can now construct the integer program itself. This is done by specifying
the constraint matrix and the rim vectors in sparse format. We will have a
variable for each possible assignment 
<FONT COLOR="#a52a2a"><SPAN CLASS="MATH"><IMG
 WIDTH="40" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.png"
 ALT="\bgroup\color{Brown}$ (i,j)$\egroup"></SPAN></FONT> with 
<FONT COLOR="#a52a2a"><SPAN CLASS="MATH"><IMG
 WIDTH="42" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="\bgroup\color{Brown}$ i&lt;j$\egroup"></SPAN></FONT>. We have a constraint
for each node 
<FONT COLOR="#a52a2a"><SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="\bgroup\color{Brown}$ i$\egroup"></SPAN></FONT>, so it can only me matched to one other node.

<P>
We define the IP in our other helper function 
<FONT COLOR="#a52a2a"><TT>match_load_problem()</TT></FONT>
in 
<FONT COLOR="#a52a2a"><TT>user_main.c</TT></FONT>. In the first part of this routine, we will build a
description of the IP, and then in the second part, we will load this
representation to SYMPHONY through

<FONT COLOR="#a52a2a"><TT>sym_explicit_load_problem()</TT></FONT>. Note that we could instead create a
description of each subproblem dynamically using the

<FONT COLOR="#a52a2a"><TT>user_create_subproblem()</TT></FONT> callback (see 
<FONT COLOR="#a52a2a"><TT>user_lp.c</TT></FONT>), but
this is more complicated and unnecessary here.

<P>

<PRE>
int match_load_problem(sym_environment *env, user_problem *prob){
   
   int i, j, index, n, m, nz, *matbeg, *matind;
   double *matval, *lb, *ub, *obj, *rhs, *rngval;
   char *sense, *is_int;
   
   /* set up the inital LP data */
   n = prob-&gt;numnodes*(prob-&gt;numnodes-1)/2;
   m = 2 * prob-&gt;numnodes;
   nz = 2 * n;

   /* Allocate the arrays */
   matbeg  = (int *) malloc((n + 1) * ISIZE);
   matind  = (int *) malloc((nz) * ISIZE);
   matval  = (double *) malloc((nz) * DSIZE);
   obj     = (double *) malloc(n * DSIZE);
   lb      = (double *) calloc(n, DSIZE);
   ub      = (double *) malloc(n * DSIZE);
   rhs     = (double *) malloc(m * DSIZE);
   sense   = (char *) malloc(m * CSIZE);
   rngval  = (double *) calloc(m, DSIZE);
   is_int  = (char *) malloc(n * CSIZE);
   
   /* Fill out the appropriate data structures -- each column has
      exactly two entries */
   index = 0;
   for (i = 0; i &lt; prob-&gt;numnodes; i++) {
      for (j = i+1; j &lt; prob-&gt;numnodes; j++) {
         prob-&gt;match1[index] = i; /*The first component of assignment 'index'*/
         prob-&gt;match2[index] = j; /*The second component of assignment 'index'*/
         /* So we can recover the index later */
         prob-&gt;index[i][j] = prob-&gt;index[j][i] = index;
         obj[index] = prob-&gt;cost[i][j]; /* Cost of assignment (i, j) */
         is_int[index] = TRUE;
         matbeg[index] = 2*index;
         matval[2*index] = 1;
         matval[2*index+1] = 1;
         matind[2*index] = i;
         matind[2*index+1] = j;
         ub[index] = 1.0;
         index++;
      }
   }
   matbeg[n] = 2 * n;
   
   /* set the initial right hand side */
   for (i = 0; i &lt; m; i++) {
      rhs[i] = 1;
      sense[i] = 'E';
   }
   
   /* Load the problem to SYMPHONY */   
   sym_explicit_load_problem(env, n, m, matbeg, matind, matval, lb, ub, 
                             is_int, obj, 0, sense, rhs, rngval, true);
			     
   return (FUNCTION_TERMINATED_NORMALLY);

}
</PRE>

<P>
Now, we are ready to gather everything in the 
<FONT COLOR="#a52a2a"><TT>main()</TT></FONT> routine in 

<FONT COLOR="#a52a2a"><TT>user_main()</TT></FONT>. This will involve to create a SYMPHONY environment and 
a user data structure, read in the data, create the corresponding IP, 
load it to the environment and ask SYMPHONY to solve it 
(
<FONT COLOR="#a52a2a"><TT>CALL_FUNCTION</TT></FONT> is just a macro to take care of the return values):  

<P>

<PRE>
int main(int argc, char **argv)
{
   int termcode;
   char * infile;

   /* Create a SYMPHONY environment */
   sym_environment *env = sym_open_environment();

   /* Create the data structure for storing the problem instance.*/
   user_problem *prob = (user_problem *)calloc(1, sizeof(user_problem));
   
   CALL_FUNCTION( sym_set_user_data(env, (void *)prob) );
   CALL_FUNCTION( sym_parse_command_line(env, argc, argv) );
   CALL_FUNCTION( sym_get_str_param(env, "infile_name", &amp;infile));
   CALL_FUNCTION( match_read_data(prob, infile) );
   CALL_FUNCTION( match_load_problem(env, prob) );
   CALL_FUNCTION( sym_solve(env) );
   CALL_FUNCTION( sym_close_environment(env) );
   return(0);
}
</PRE>

<P>
OK, that's it. That defines an integer program, and if you compile and
optimize it, the rest of the system will come together to solve this problem.
Here is a data file to use:

<PRE>
6
0 1 1 3 3 3
1 0 1 3 3 3
1 1 0 3 3 3
3 3 3 0 1 1
3 3 3 1 0 1
3 3 3 1 1 0
</PRE>

<P>
The optimal value is 5. To display the solution, we need to be able to map
back from variables to the nodes. That was the use of the 
<FONT COLOR="#a52a2a"><TT>node1</TT></FONT> and

<FONT COLOR="#a52a2a"><TT>node2</TT></FONT> parts of the 
<FONT COLOR="#a52a2a"><TT>USER_PROBLEM</TT></FONT>. We can now use

<FONT COLOR="#a52a2a"><TT>user_display_solution()</TT></FONT> in 
<FONT COLOR="#a52a2a"><TT>user_master.c</TT></FONT> to print 
out the solution:

<P>

<PRE>
int user_display_solution(void *user, double lpetol, int varnum, int *indices,
                          double *values, double objval)
{
   /* This gives you access to the user data structure. */
   user_problem *prob = (user_problem *) user;
   int index;
 
   for (index = 0; index &lt; varnum; index++){
      if (values[index] &gt; lpetol) {
          printf("%2d matched with %2d at cost %6d\n",
                prob-&gt;node1[indices[index]],
                prob-&gt;node2[indices[index]],
                prob-&gt;cost[prob-&gt;node1[indices[index]]]
                [prob-&gt;node2[indices[index]]]);
      }	   
   }
   
   return(USER_SUCCESS);
}
</PRE>

<P>
We will now update the code to include a crude cut generator. Of course, We
could go for a Gomory-Hu type odd-set separation (ala Gr&#246;tschel and Padberg)
but for the moment, let's just check for sets of size three with more than
value 1 among them (such a set defines a cut that requires at least one edge
out of any odd set). We can do this by brute force checking of triples, as
follows:

<P>

<PRE>
int user_find_cuts(void *user, int varnum, int iter_num, int level,
                   int index, double objval, int *indices, double *values,
                   double ub, double etol, int *num_cuts, int *alloc_cuts, 
                   cut_data ***cuts)
{
   user_problem *prob = (user_problem *) user;
   double edge_val[200][200]; /* Matrix of edge values */
   int i, j, k, cutind[3];
   double cutval[3];
   
   int cutnum = 0;

   /* Allocate the edge_val matrix to zero (we could also just calloc it) */
   memset((char *)edge_val, 0, 200*200*ISIZE);
   
   for (i = 0; i &lt; varnum; i++) {
      edge_val[prob-&gt;node1[indices[i]]][prob-&gt;node2[indices[i]]] = values[i];
   }
   
   for (i = 0; i &lt; prob-&gt;nnodes; i++){
      for (j = i+1; j &lt; prob-&gt;nnodes; j++){
         for (k = j+1; k &lt; prob-&gt;nnodes; k++) {
            if (edge_val[i][j]+edge_val[j][k]+edge_val[i][k] &gt; 1.0 + etol) {
               /* Found violated triangle cut */
               /* Form the cut as a sparse vector */
               cutind[0] = prob-&gt;index[i][j];
               cutind[1] = prob-&gt;index[j][k];
               cutind[2] = prob-&gt;index[i][k];
               cutval[0] = cutval[1] = cutval[2] = 1.0;
               cg_add_explicit_cut(3, cutind, cutval, 1.0, 0, 'L',
                                   TRUE, num_cuts, alloc_cuts, cuts);
               cutnum++;
            }
         }
      }
   }

   return(USER_SUCCESS);
}
</PRE>

<P>
Note the call of 
<FONT COLOR="#a52a2a"><TT>cg_add_explicit_cut()</TT></FONT>, which tells SYMPHONY about
any cuts found. If we now solve the matching problem on the sample data set,
the number of nodes in the branch and bound tree should just be 1 (rather than
3 without cut generation).

<P>

<P>

<DIV CLASS="navigation"><HR>
<A NAME="tex2html1970"
  HREF="node117.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1966"
  HREF="node97.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1962"
  HREF="node115.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1968"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  <BR>
<B> Next:</B> <A NAME="tex2html1971"
  HREF="node117.html">Reference</A>
<B>Up:</B> <A NAME="tex2html1967"
  HREF="node97.html">Developing Custom Applications</A>
<B> Previous:</B> <A NAME="tex2html1963"
  HREF="node115.html">Other Debugging Techniques</A>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Ted Ralphs <BR>
2011-05-30</I>
</ADDRESS>
</BODY>
</HTML>
