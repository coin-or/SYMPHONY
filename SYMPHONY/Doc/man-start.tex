%===========================================================================%
%                                                                           %
% This file is part of the documentation for the SYMPHONY MILP Solver.      %
%                                                                           %
% SYMPHONY was jointly developed by Ted Ralphs (tkralphs@lehigh.edu) and    %
% Laci Ladanyi (ladanyi@us.ibm.com).                                        %
%                                                                           %
% (c) Copyright 2000-2006 Ted Ralphs. All Rights Reserved.                  %
%                                                                           %
% SYMPHONY is licensed under the Common Public License. Please see          %
% accompanying file for terms.                                              %
%                                                                           %
%===========================================================================%

This chapter is concerned with detailed instructions for building and
installing \BB, along with its associated libraries and applications.

\section{Installing the Binary Distribution}

For the users who only need the generic MILP solver or the SYMPHONY 
callable library to be used in their custom applications, there are 
binary distributions released for different compilers and platforms. 
Each distribution consists of an executable and libraries built from the 
source code of SYMPHONY version \VER.
 
You can obtain the SYMPHONY binary distribution from 
{\color{Brown}
\begin{verbatim}
 https://projects.coin-or.org/SYMPHONY
\end{verbatim}
}

The binaries are currently available for Linux and Windows. These binaries are
built with the following default options:
\begin{itemize}
\item The LP solver is the COIN LP solver (CLP).
\item Cut generation with COIN's Cut Generation Library (CGL) is enabled.
\item All libraries are static.
%\item Library linked with = CLP, CGL, COINUTILS, OSI, OSICLP, OSISYM, 
\item The optization level (Linux) is ``O2''. 
\item Only serial executables are included.
\end{itemize} 

Note that by building your own libraries and executables, you get additional
functionality, since we are not able to distribute an executable that links
with code distributed under the GNU General Public License, which includes
several useful libraries SYMPHONY can take advantage of. See Sections
\ref{getting_started_unix} and \ref{getting_started_windows} for instructions
for building SYMPHONY from source with other options, including the parallel
configuration.
% such as another LP
%solver, enabling GMPL reader or building SYMPHONY for parallel architectures.

\subsection{Installation for Unix-like environments}
\begin{itemize}
\item Unpack the distribution with
{\color{Brown}
\begin{verbatim}
 tar xzvf symphony-\VER-XXX.tgz
\end{verbatim}
}
where \texttt{XXX} is the platform and the version of 
compiler used to build the distribution. 
Switch into the root directory of the unpacked distribution. 

\item First, test the executable by going to the \texttt{bin} directory and
typing 
{\color{Brown}
\begin{verbatim}
 ./symphony -F ../test/sample.mps
\end{verbatim}
}
\item To test the library, the distribution
includes sample files in \texttt{test} directory:  \\
\underbar{milp.c}: This sample code is an implementation of a basic MILP
solver using SYMPHONY's C callable functions with user defined input (see
Section
\ref{callable_library}). To test the code, go to \texttt{test} directory and
type, {\color{Brown}
\begin{verbatim}
 make milp 
 milp
 \end{verbatim}
}
\underbar{milpOsi.c}: This sample code is an implementation of a basic MILP 
solver using SYMPHONY's C++ callable functions (through OsiSym interface)
with user defined input (see Section \ref{OSI}). To test the code, 
go to \texttt{test} directory and type, 
{\color{Brown}
\begin{verbatim}
 make milpOsi
 milpOsi
 \end{verbatim}
}
\end{itemize}


\subsection{Installation for Microsoft Visual C++}
Direct support is provided only for MS Visual Studio 6.0. 
Download and unzip the archive \texttt{symphony-\VER-winv6.zip} 
\begin{itemize}
\item To test the executable, open a command line terminal,  
switch into the root directory of the distribution and type, 
{\color{Brown}
\begin{verbatim}
 bin\symphony.exe -F Examples\sample.mps
 \end{verbatim}
}
\item To test the callable library, the distribution includes sample codes with
their project files in \texttt{test} directory. 
\begin{itemize}
\item milp.c: This sample code is an implementation of a basic MILP solver 
using SYMPHONY's C callable functions with user defined input 
(see Section \ref{callable_library}). 
To test the code, either 

\begin{itemize}
\item open the workspace \texttt{milp.dsw}, choose \texttt{Build milp.exe}
and then choose \texttt{Execute} from the \texttt{Build} menu, 
\end{itemize}
or
\begin{itemize}
\item open a command line terminal, and type 
{\color{Brown}
\begin{verbatim}
 msdev milp.dsw /make "all - debug"
 Debug/milp.exe
 \end{verbatim}
}
\end{itemize}
\item  milpOsi.c: This sample code is an implementation of a basic MILP 
solver using SYMPHONY's C++ callable functions (through OsiSym interface)
with user defined input (see Section \ref{OSI}). To test the code, either 
\begin{itemize}
\item open the workspace \texttt{milpOsi.dsw}, 
choose \texttt{Build milpOsi.exe} and then 
\texttt{Execute} commands from the \texttt{Build} menu, 
\end{itemize}
or
\begin{itemize}
\item open a command line terminal, and type 
{\color{Brown}
\begin{verbatim}
 msdev milpOsi.dsw /make "all - debug"
 Debug/milpOsi.exe
 \end{verbatim}
}
\end{itemize}
\end{itemize}
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Building from source in Unix-like environments}
\label{getting_started_unix}

SYMPHONY now uses the COIN-OR build system and the GNU autotools to automate
the build process. The build process should therefore be identical in all
Unix-like environments. These instructions will lead you through the steps
required to compile SYMPHONY as a generic MILP solver. This process will
create (1) a generic callable library that allows SYMPHONY to be called from
an application and (2) an executable that can be used as a stand-alone
application to solve MILPs written in either MPS or GMPL file format. SYMPHONY
can be further customized by implementing one of more than 50 callback
functions that change SYMPHONY's default execution of its algorithm. For
information on customizing SYMPHONY using callbacks, a quick start guide is
provided below.

\subsection{Downloading}

You can obtain the SYMPHONY source code either via the subversion repository
or in the form of daily tarballs. The recommended method is to use subversion
because it makes it easier to obtain updates. In a Unix-like environment (such
as Linux or CYGWIN), the following command may be used to obtain SYMPHONY from
source using SVN in most cases:
{\color{Brown}
\begin{verbatim}
 svn checkout https://projects.coin-or.org/svn/SYMPHONY/trunk/ COIN-SYMPHONY
\end{verbatim}
}
Alternatively, you can get a daily snapshot of the source code as a tarball
from the download page of COIN-OR:
{\color{Brown}
\begin{verbatim}
 http://www.coin-or.org/Tarballs/
\end{verbatim}
}
If the code is obtained as a tarball, unpack the distribution with 
{\color{Brown}
\begin{verbatim}
 tar -xzf SYMPHONY_XXX.tgz
\end{verbatim}
}
where ``\texttt{XXX}'' is the date the snapshot is taken. This will create a
subdirectory called \texttt{SYMPHONY\_XXX/} containing the distribution.

\subsection{Configuring}\label{configuring}

The first step is to run a configuration script that will allow the
compilation process to be customized for your environment. to perform this
step, switch into the root directory of the distribution and type
{\color{Brown}
\begin{verbatim}
 ./configure 
\end{verbatim}
}
This will set up the default configuration files. If you want to override the
default settings, you can either run the configuration script with
command-line options or else modify the options in the file
'share/config.site'. A complete list of options with brief
explanations can be seen both in the file 'share/config.site' and by typing
{\color{Brown}
\begin{verbatim}
 ./configure --help=recursive 
\end{verbatim}
}
See Figure \ref{conf_opts} for a list of options the user may want to set. 

\begin{figure}[htb]
\begin{tabular}{ll}
\hline
\texttt{--enable-debug} & compile all projects with debug options set \\
\texttt{--enable-debug-symphony} & compile only SYMPHONY project with debug options \\
\texttt{--enable-static} & build static libraries \\
\texttt{--enable-static-executable} &  create a complete static executable \\
\texttt{--enable-gnu-packages} & compile with GNU packages \\ 
& compile interactive optimizer with readline library \\
\hline
\texttt{--disable-cgl-cuts} & disable generic cut generation \\
\texttt{--enable-sensitivity-analysis} & compile in the sensitivity analysis features \\
\texttt{--enable-root-only} & process only the root node \\
\texttt{--enable-frac-branching} & compile in the fractional branching option \\
\texttt{--enable-tests}&  perform additional sanity checks (for debugging purposes) \\
\texttt{--enable-tm-tests }& perform more tests  \\
\texttt{--enable-trace-path}&  additional debugging options \\
\texttt{--enable-cut-check}& additional debugging options \\
\texttt{--enable-statistics}& additional statistics \\
\texttt{--enable-pseudo-costs}& enable some experimental pseudo-cost branching tools \\
\texttt{--enable-draw-graph} &  enable IGD graph drawing application \\
\hline
\texttt{ --with-XXX-incdir} &  specify the directory with the header files for the XXX package \\ 
&where XXX is one of LP solver packages: cplex, glpk, osl, soplex, \\ 
& xpress \\
\texttt{--with-XXX-lib} &  specify the flags to link with the library  
XXX package \\ 
&where XXX is one of LP solver packages: cplex, glpk, osl, soplex, \\ 
& xpress \\
\texttt{--with-lp-solver[=lpsolver]} &  specify the LP solver in small 
letters (default lpsolver=clp) \\
\texttt{ --with-gmpl} &  compile with GMPL reader (requires 
\texttt{--with-glpk-incdir} and \\ &
\texttt{--with-glpk-lib} options to be set) \\
\texttt{--with-osi-interface} &  compile with SymOsi interface \\
\texttt{--with-application} &  compile the application library \\
\hline
\texttt{--enable-openmp} &   compile in OpenMP features \\
\texttt{--with-pvm } &  compile in parallel architecture (assuming that pvm is \\ 
&installed and the variable PVM\_ROOT is defined.) \\
\texttt{--without-cg} &  compile without cut generator module \\
\texttt{--without-cp} &  compile without cut pool module \\
\texttt{--without-lp} &  compile without LP solver module \\
\texttt{--without-tm} &  compile without tree manager module
\end{tabular}
\caption{A list of useful configuration options \label{conf_opts}}
\end{figure}

In order to enable or disable an option, either update the file 
'share/config.site' or add the option as an argument to configuration script. 
As an instance for the second case, running 
{\color{Brown}
\begin{verbatim}
 ./configure --enable-debug
\end{verbatim}
}
will set the configuration to compile the source files with debugging
flag. 

\subsection{Building}\label{building}

After configuring, the code can be built by typing the commands
{\color{Brown}
\begin{verbatim}
 make
 make install
\end{verbatim}
}
This will first create the required libraries and binaries and then will
install them. By default, the library \texttt{libSym} and the executable
\texttt{symphony} will be installed to the \texttt{lib/} and \texttt{bin/}
directories.

After compilation, the SYMPHONY library, together with the header files in the
subdirectory \texttt{include/}, can then be used to call SYMPHONY from any
C/C++ code. The API for this is described in Chapter~\ref{API-overview}. The
executable can also be used for solving generic MILP problems in MPS and GMPL
format. In order to read GMPL files, you will need to have GLPK 
(\url{http://www.gnu.org/software/glpk/}) installed and
SYMPHONY must be configured with
{\color{Brown}
\begin{verbatim}
 ./configure --with-gmpl --with-glpk-lib[=GLPK library] 
             --with-glpk-incdir[=GLPK include dir] 
\end{verbatim}
}
For more pwerful modeling interface, FlopC++ can also be used to obtain a
capability similar to ILOG's Concert technology for building math programming
models (see SYMPHONY/Examples/FLOPC++). 

To test SYMPHONY after building, type
{\color{Brown}
\begin{verbatim}
 make test
\end{verbatim}
}
to execute an automated unit test. To test out the optimizer manually. a
sample MPS file called "sample.mps" and a sample GMPL/AMPL file called
"sample.mod" together with its data file "sample.dat" are included with the
distribution. You can use either the command-line or the interactive
optimizer. To solve the sample MPS model, type 
{\color{Brown}
\begin{verbatim}
 bin/symphony -F SYMPHONY/Datasets/sample.mps
\end{verbatim}
}
To solve the GMPL model, use the "-F" switch to specify the file
name and the "-D" for the data file name if the input is in GMPL/AMPL format,
i.e., type
{\color{Brown}
\begin{verbatim}
 bin/symphony -F SYMPHONY/Datasets/sample.mod -D SYMPHONY/Datasets/sample.dat
\end{verbatim}}
For more MPS data files for further testing, see the MIPLIB library in the
Data/ subdirectory. To run the interactive optimizer, execute SYMPHONY without
any command-line arguments, i.e., type
{\color{Brown}
\begin{verbatim}
  bin/symphony 
\end{verbatim}}
and then type "help" or "?" to see a list of available commands.
After the SYMPHONY library and the executable are compiled and tested, you
can type
{\color{Brown}
\begin{verbatim}
 make clean 
\end{verbatim}}
if you want to save disk space. That's it! Now you are ready to use SYMPHONY
callable library or solve generic MILP problems through the executable.

\section{Building for shared-memory multiprocessor architecture}

To compile a shared memory version of SYMPHONY, simply use an OpenMP compliant
compiler. Version \VER has been tested with gcc 4.2, and should work by
configuring with
{\color{Brown}
\begin{verbatim}
 ./configure -enable-openmp
\end{verbatim}
}
Follow the instructions above for building and testing. To invoke SYMPHONY
from the command-line with multiple threads, specify the number of threads
with the \texttt{-p} option, i.e.,
{\color{Brown}
\begin{verbatim}
 bin/symphony -p 2 -F SYMPHONY/Datasets/sample.mps
\end{verbatim}
}
\section{Building for distribuited-memory architectuires}

If you wish to compile a distributed version of the code, first make sure
you have PVM installed. You can obtain it from
\url{http://www.csm.ornl.gov/pvm/}. To configure for a parallel build, invoke
the configuration script as follows:
{\color{Brown}
\begin{verbatim}
 ./configure --with-pvm
\end{verbatim}
}
Be sure that PVM is installed either in system path or that you have the
environment variable \texttt{PVM\_ROOT} set properly. Note that there are a
number of different parallel configurations. The default configuration is to
build two parallel modules. The first one consists of the master, tree
management, and cut management modules, while the second one consists of the
node processing, and cut generation modules. For other configuration options,
see the share/config.site file.

Follow the build instructions above to build the code. Note that this will
also compile the sequential version. Make sure there are links from your
\texttt{\$PVM\_ROOT/bin/\$PVM\_ARCH} subdirectoryto each of the executables in
your \texttt{bin/} directory. This is required by PVM.

To test the parallel version, first start the PVM daemon by typing
\texttt{pvm} on the command line and then typing \texttt{quit}. As above,
invoke SYMPHONY using the sample MPS file called \texttt{sample.mps} included
with the distribution. To specify the file name, use the \texttt{-F}
command-line option, i.e., in the root directory, type
{\color{Brown}
\begin{verbatim}
 bin/symphony_m\$(EXT) -F SYMPHONY/Datasets/sample.mps 
\end{verbatim}
}
where \texttt{\$(EXT)} is an extension to be added according to the chosen
module dependencies. To obtain more MPS data files for further testing,
download the MIPLIB library.

\section{Building a SYMPHONY Application}
\label{build_appl}
In order to compile SYMPHONY's applications, you must first compile the 
application-specific library with
{\color{Brown}
\begin{verbatim}
 ./configure --with-applications 
 make 
 make install
\end{verbatim}
}
This will create the application library called 'libSymAppl' to be used while
building custom applications. Note that that sequential version library and
executable will also be made and installed.

After building the library, go to one of the application subdirectories in the
\texttt{SYMPHONY/Applications/} directory and type \texttt{make} there. For
more information, including the parallel configuration instructions, see the
INSTALL file of the corresponding application.

\section{Building from source Using the Microsoft Visual C++ compiler}
\label{getting_started_windows}

Here is a sketch outline of how to compile \BB\ in MS Windows.
These instructions will lead you through the steps required to compile
\BB as a generic MILP solver. Direct support
is provided for compilation with MS Visual Studio 6.0. Compilation for other
compilers should also be possible. Note that the Windows version has some
limitations. Detailed timing information is not currently provided. Support is
only provided for running in sequential mode at this time.

First, download \texttt{SYMPHONY-\VER.zip} and unzip the archive. This will
create a subdirectory called \texttt{SYMPHONY-\VER} containing all the source
files.You now 
have three options. You can either compile on the command-line using automated 
MSDEV build system or NMAKE utility or you can use the provided projects and 
workspaces. Compiling on the command-line is somewhat easier since it requires 
only typing a single command or editing the makefile. 

\subsection{Using the MSDEV Utility}
\label{using_msdev}
\begin{itemize}
\item Open a command line terminal. Go to \texttt{Win32\bs v6} directory and 
type
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make all
\end{verbatim}
}
This will create both the debug and release versions of SYMPHONY. If you 
want to compile only one of them, type
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make "all - debug"
\end{verbatim}
}
or 
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make "all - release"
\end{verbatim}
}
For each command, the library \texttt{libSymphony.lib} and the executable 
\texttt{symphony} will be created in \texttt{Debug} and/or \texttt{Release}
directories.  The library, together with the header files in 
\texttt{SYMPHONY\bs include\bs}, can then be 
used to call \BB from any C/C++ code. The API for calling \BB is 
described in Section \ref{callable_library}.

\item To test the executable, type 
{\color{Brown}
\begin{verbatim}
 Debug\symphony.exe -F ..\..\SYMPHONY\Datasets\sample.mps
\end{verbatim}
}
If you want to use the interactive optimizer, simply type
{\color{Brown}
\begin{verbatim}
 Debug\symphony.exe
\end{verbatim}
}
and then type "help" or "?" to see a list of available commands.

\item If SYMPHONY is modified, type 
{\color{Brown}
\begin{verbatim}
 msdev symphony.dsw /make all /rebuild
\end{verbatim}
}
in order to clean and rebuild everything.
\end{itemize} 
\subsection{Using the NMAKE Utility}
\label{using_nmake}
\begin{itemize}
\item Go to \texttt{Win32/v6} directory and edit the \texttt{sym.mak} 
makefile to reflect 
your environment. This involves specifying the LP solver to be used, 
assigning some variables and  setting various paths. Only minor edits 
should be required. An explanation of what has to be set is contained in the 
comments in the makefile.  Note that, you have to first create the COIN 
libraries \ptt{Cgl}, \ptt{Clp}, \ptt{Osi}, \ptt{OsiClp} and \ptt{CoinUtils} 
which reside in \texttt{Win32/v6} directory.

\item Once configuration is done, open a command line terminal and type 
{\color{Brown}
\begin{verbatim}
 nmake /f sym.mak
\end{verbatim}
}
This will make the SYMPHONY library 'libSymphony.lib' and the executable 
'symphony' in \texttt{Debug} directory. The library, together with the 
header files in \texttt{SYMPHONY\bs include\bs}, can then be used to call 
SYMPHONY from any C/C++ code. The API for calling SYMPHONY is described in 
Section \ref{callable_library}.

\item To test the executable, type 
{\color{Brown}
\begin{verbatim}
  Debug\symphony.exe -F ..\..\SYMPHONY\Datasets\sample.mps
\end{verbatim}
}

If you want to use the interactive optimizer, simply type  
{\color{Brown}
\begin{verbatim}
 Debug\symphony.exe 
\end{verbatim}
}
and then type "help" or "?" to see a list of available commands.
\end{itemize}

\subsection{Using the MSVC++ Workspace}

\begin{itemize}

\item Go to \texttt{Win32\bs v6} directory and open the workspace 
\texttt{symphony.dsw}. 

\item Note that there are a number of additional preprocessor definitions that
control the functionality of SYMPHONY. These definitions are described in
\texttt{sym.mak}, a Unix-style makefile included in the distribution. To 
enable the functionality associated with a particular definition, simply add 
it to the list of definitions of \texttt{libSymphony} project together with 
the required libraries and paths. For instance, if you 
want to enable GMPL reader option, you need to
\begin{itemize}
  \item add the directory of the header files of GLPK to the include 
files path
  \item add \texttt{USE\_GLPMPL} to the defines
  \item add the GLPK library to the workspace
\end{itemize}
\item Make sure that the project \texttt{symphony} is set as the active 
project from the Project/Set Active menu. Choose 
\texttt{Build symphony.exe} from the Build menu. This should successfully 
build the SYMPHONY library and the corresponding executable.

\item To test the executable, right click on the symphony project, go to the
\texttt{Debug} tab and set the program arguments to 
{\color{Brown}
\begin{verbatim}
 -F ..\..\SYMPHONY\Datasets\sample.mps 
\end{verbatim}
}
Note that command-line switches are Unix-style. If you want to use the 
interactive optimizer, leave this tab empty. 

4. Now choose \texttt{Execute} from the Build menu and the solver should 
solve the given sample problem. If you have not specified the sample problem, 
then the interactive optimizer should start. In this case, 
type "help" or "?" to see a list of available commands
\end{itemize}

Note that there is some functionality missing from the Windows version. Most
prominently, the timing functions do not work. This functionality
should be easy to add---let me know if you are interested in doing it and I
will give you all the help I can. In addition, the Windows version will only
run in sequential mode for a variety of reasons. However, it should be
relatively easy to get it running in parallel if you can get PVM working under
Windows. Let me know if you are interested.

%\section{Using SYMPHONY}

%\subsection{Using the SYMPHONY executable}

%To use SYMPHONY as a generic solver, type the executable name followed by one
%or more of the command-line switches. There are two required switches. You
%must specify the location of the input file by using ``-F 'filename'.'' This
%input file is assumed to be in MPS format, unless the ``-D'' switch is also
%present, in which case the file will be assumed to be in GMPL model file
%format with the data file specified after the ``-D'' switch. Some of
%SYMPHONY's native parameters can also be set on the command line. Below is a
%list of these parameters. This list can also be obtained by typing the
%executable name with no command-line arguments. Note that all SYMPHONY
%parameters are denoted by a lowercase letter. Note that there are dozens of
%other parameters that can be set with the use of a parameter file. These
%parameters are listed in the SYMPHONY user's manual.

%\subsection{Using the SYMPHONY callable library}

%To use SYMPHONY as a generic callable library, compile SYMPHONY as described
%above. The library that is created along with the solver itself can be linked
%to using the API described Section \ref{callable-library}. As an example of
%using the callable library in this way, see the multi-criteria knapsack
%application (MCKP).

\section{Compiling a Custom Application Using Callbacks}

\subsection{Unix}

First, configure and compile SYMPHONY \VER as described in
Section \ref{build_appl}. This will generate the required library
and the makefiles for each application. Modify the variables in the 
SYMPHONY/Applications/USER/Makefile appropriately. 
Typing "make" in the USER subdirectory should successfully make
the USER executable. For more information, including the parallel 
configuration instuctions, see the 
SYMPHONY/Applications/USER/INSTALL file. 
After you've successfully compiled the code, you can develop your custom 
application by following the
instructions for filling in the user callback functions as described in
Section \ref{SYMPHONY-development}.

\subsection{Microsoft Windows}

First, download \texttt{SYMPHONY-\VER} and unpack the archive if it is 
required. You now have three options. You can either compile on the 
command-line using the automated MSDEV build system or NMAKE utility or you can 
use the provided projects and workspaces. Note that, in Windows, it is not 
recommended to move USER package from the SYMPHONY package. Otherwise, 
the user has to redefine all the paths to SYMPHONY and COIN header files 
as well as the paths to COIN project files. For all of the following options, 
first go to the \texttt{SYMPHONY\bs Applications\bs USER\bs Win32\bs v6} 
directory.

\subsection{Using the MSDEV Utility}
\begin{itemize}
\item Open a command line terminal and type
{\color{Brown}
\begin{verbatim}
 msdev user.dsw /make all
\end{verbatim}
}
This will create both the debug and release versions of USER application. 
If you want to compile only one of them, type
{\color{Brown}
\begin{verbatim}
 msdev user.dsw /make "all - debug"
\end{verbatim}
}
or 
{\color{Brown}
\begin{verbatim}
 msdev user.dsw /make "all - release"
\end{verbatim}
}
For each command, the executable \texttt{user} will be created in 
\texttt{Debug} and/or \texttt{Release}
directories. 

\item To test the executable, type 
{\color{Brown}
\begin{verbatim}
 Debug\user.exe -F ..\..\sample.user
\end{verbatim}
}
\item If USER source files are modified, type 
{\color{Brown}
\begin{verbatim}
 msdev user.dsw /make all /rebuild
\end{verbatim}
}
in order to clean and rebuild everything.
\end{itemize} 

\subsection{Using the NMAKE Utility}

\begin{itemize}
\item 
Edit the file \texttt{user.mak} to reflect your environment. 
Only minor edits should be required. An explanation of 
what has to be set is contained in the comments in the makefile. 
This basically 
requires the same routines that one needs to walk through in 
\texttt{SYMPHONY}'s makefile. 
See the related parts of \ref{using_nmake} section 
of \texttt{SYMPHONY} above.

\item Once configuration is done, type 
{\color{Brown}
\begin{verbatim}
  nmake /f user.mak
\end{verbatim}
}
The executable \texttt{user.exe} will be created under the 
\texttt{Debug} directory.
\item To test the executable, type 
{\color{Brown}
\begin{verbatim}
 Debug\user.exe -F ..\..\sample.user
\end{verbatim}
}
\end{itemize}

\subsection{Using the MSVC++ Workspace}

\begin{itemize}
\item Open the workspace 
\texttt{user.dsw}.

\item 
The configuration steps are exactly the same with the MSVC++ section of 
\texttt{SYMPHONY}. The only 
difference is that, you have the \texttt{user} project instead of the
\texttt{symphony} project. Go through the related steps of section 
\ref{getting_started_windows} to see how to get USER executable. 

\item
Once you have the proper settings, choose \texttt{Build
user.exe} from the \texttt{Build} menu. This should successfully 
build the executable.

\item
To test the executable, right click on the \texttt{user} project, go to the
\texttt{Debug} tab and set the program arguments to 
\texttt{-F ..\bs ..\bs sample.mps}. Note that command-line switches are 
Unix-style.

\item
Now choose \texttt{Execute} from the build menu and you have a working branch
and bound solver! After successful compilation, you can fill in the user
callback functions as describe in Section \ref{SYMPHONY-development}.
\end{itemize}

\section{Sample Applications}

There are a number of sample applications available as examples of how to do
development with \BB. These include solvers for the matching problem, the set
partitioning problem (simple and advanced versions), the vehicle routing and
traveling salesman problems, the mixed postman problem, multi-criteria 
knapsack problem and, capacitated
network routing problem. These applications are distributed as separate
packages and can be downloaded either from
\texttt{\htmladdnormallink{http://www.projects.coin-or/SYMPHONY}{http://www.projects.coin-or/SYMPHONY/}} or from 
\texttt{\htmladdnormallink{http://www.branchandcut.org/SYMPHONY}{http://www.branchandcut.org/SYMPHONY/}}. There is also a white paper that guides the
user through the development of the matching solver.
