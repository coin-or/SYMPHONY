SYMPHONY Version 5.1 INSTALLATION
=================================

******************************************************************************
*   COMPILING The SYMPHONY Library and Executable (UNIX Operating Systems)   *
******************************************************************************

Here is a sketch outline of how to get started with SYMPHONY in Unix. These
instructions will lead you through the steps required to compile SYMPHONY as a
generic MILP solver. This process will create (1) a generic
callable library that allows SYMPHONY to be called from an application and (2)
an executable that can be used as a stand-alone application to solve MILPs
written in either MPS or GMPL file format. SYMPHONY can be further customized
by implementing one of more than 50 callback functions that change SYMPHONY's
default execution of its algorithm. For information on customizing SYMPHONY
using callbacks, a quick start guide is provided below.

PREPARING FOR COMPILATION
=========================

1. You can obtain the SYMPHONY source code either via the subversion 
repository or in the form of daily tarballs. 

The recommended method is to use subversion because it makes it easier to 
obtain updates. In a Unix-like environment (such as Linux or CYGWIN), 
the following command may be used to obtain SYMPHONY from 
source using SVN in most cases:

   svn checkout https://projects.coin-or.org/svn/SYMPHONY/trunk/ COIN-SYMPHONY

The alternative way is to get a daily snapshot of the source code as a tarball 
from  the download page of COIN-OR:

   http://www.coin-or.org/Tarballs/

2. If the code is obtained as a tarball, unpack the distribution with 
"tar -xzf SYMPHONY_XXX.tgz" where XXX is the date the snapshot is taken. 
This will create a subdirectory called SYMPHONY_XXX containing the 
distribution.

COMPILING FOR SEQUENTIAL VERSION
=================================

1. The user simply has to run 

   ./configure 

in the root directory. This will set up the default configuration for 
SYMPHONY. If you want to override the default settings, run the configuration 
script with required options to reflect your environment. This usually 
involves specifying the LP solver to be used, assigning some variables and 
setting the paths to various libraries and include files. A list of options 
together with brief explanations can be seen both in the file 
'share/config.site' and by typing  

   ./configure --help=recursive 

In order to enable or disable an option, either update the file 
'share/config.site' or add the option as an argument to configuration script. 
As an instance for the second case, running 

    ./configure --enable-debug

will set the configuration to compile the source files with debugging
flag. 

2. After configuring SYMPHONY, type 

   make
   make install

This will first create the required libraries and binaries and then will 
install SYMPHONY. By default, the library 'libSym' and the executable 
'symphony' will be installed to the 'lib/' and 'bin/' directories. 

3. The SYMPHONY library, together with the header files in the subdirectory 
'include/', can then be used to call SYMPHONY from any C/C++ code. The API for 
this is described in the user's manual. On the other hand, the executable can 
be used for solving generic MILP problems in MPS format. In order to read 
GMPL files, you need to have the GLPK package and SYMPHONY has to be 
configured with 

  ./configure --with-gmpl --with-glpk-lib[=GLPK library] 
              --with-glpk-incdir[=GLPK include dir] 


FlopC++ can also be used to obtain a capability similar to ILOG's Concert 
technology for building math programming models 
(see SYMPHONY/Examples/FLOPC++). The configuration file can also be modified 
to enable parallel execution of the code (see below).

4. After the SYMPHONY library and the executable are compiled, you are free 
to type "make clean" if you want to save disk space. You should only have to 
remake the SYMPHONY library if you change something in SYMPHONY's 
internal files.

5. To test SYMPHONY, a sample MPS file called "sample.mps" and a sample 
GMPL/AMPL file called "sample.mod" together with its data file "sample.dat" are
included with the distribution. You can use either the command-line or the 
interactive optimizer. For the first option, use the "-F" 
command-line option to specify the file name and the "-D" for the data 
file name if the input is in GMPL/AMPL format, i.e., type 

   bin/symphony -F SYMPHONY/Datasets/sample.mps

or 

  bin/symphony -F SYMPHONY/Datasets/sample.mod -D SYMPHONY/Datasets/sample.dat

To obtain more MPS data files for further testing, download the MIPLIB library.

For the interactive optimizer, it is recommended to run the configuration 
script with 

  ./configure --enable-gnu-packages 

This will allow the interactive shell to be able to behave exactly like 
a Linux terminal command line, i.e., it will keep the history of the used 
commands, will complete the input word to possible commands, etc. Make sure
that you have the needed package (readline.h and history.h include files 
and their libraries) on the system files path. To start the optimizer, call 
the executable without any command-line arguments, i.e., type 

   bin/symphony 

and then type "help" or "?" to see a list of available commands.

6. That's it! Now you are ready to use SYMPHONY callable library or 
solve generic MILP problems through the executable.

COMPILING FOR SHARED MEMORY
===========================

1. To compile a shared memory version, obtain an OpenMP compliant compiler,
such as Omni (free from http://phase.etl.go.jp/Omni). Other options are listed
at http://www.openmp.org.

2. Follow the instructions above for modifying the configuration file. Set the
variable CC to the compiler name and compile as above. Note that if you have 
previously compiled the sequential version, then you should first type "make 
clean_all", as this version uses the same directories. With one thread allowed,
it should run exactly the same as the sequential version so there is no need 
to compile both versions.

3. Voila, you have a shared memory parallel solver! As above, test symphony,
using the sample MPS file called sample.mps included with the distribution. To
specify the file name, use the "-F" command-line option, i.e., type
"bin/symphony -F SYMPHONY/Datasets/sample.mps". To obtain more MPS data 
files for further testing, download the MIPLIB library.

4. That's it! Now, you are ready to develop your own application using 
SYMPHONY callable library or solve MILP problems using the executable. See the
user manual for help.

COMPILING FOR DISTRIBUTED NETWORKS
==================================

PLEASE NOTE THAT THE DISTRIBUTED MEMORY PARALLEL VERSION HAS NOT BEEN TESTED
IN VERSION 5.0 AND MAY BE BROKEN. PLEASE LET ME KNOW IF YOU WANT TO USE IT AND
I WILL GET IT WORKING.

1. If you wish to compile a distributed version of the code, obtain and
install PVM from http://www.csm.ornl.gov/pvm/.

2. While configuring, run 

   ./configure --with-pvm

Be sure that, you have PVM installed either in system path or PVM_ROOT
set as a bash environment variable. By default, configuration will assume
the following module dependencies: '--with-cg=yes --with-cp=yes --with-lp=no 
--with-tm=yes' (see the user manual or the file 'share/config.site' for more 
information). If you configure with

   ./configure --with-pvm --with-lp=yes

then you will end up with the sequential version. Therefore, if you want 
to override the default set up, you must configure without one or more of 
module dependencies. 

3. As above, type 
  
    make 
    make install

in the root directory to make and install the distributed libraries. As in 
Step 1 of the sequential version, you may type "make clean" after making the 
library. It should not have to be remade again unless you modify SYMPHONY's 
internal files.

5. Make sure there are links from your '$PVM_ROOT/bin/$PVM_ARCH/' subdirectory 
to each of the executables in your 'bin/' directory. This is required by PVM.

6. Start the PVM daemon by typing "pvm" on the command line and then typing
"quit".

7. As above, test SYMPHONY using the sample MPS file called sample.mps included
with the distribution. To specify the file name, use the "-F" command-line
option, i.e., type 

   bin/symphony -F SYMPHONY/Datasets/sample.mps 

in the root directory. To obtain more MPS data files for further
testing, download the MIPLIB library.

4. That's it! Now, you are ready to develop your own application using 
SYMPHONY callable library or solve MILP problems using the executable. See the
user manual for help.

COMPILING FOR APPLICATIONS
==================================

1. In order to compile SYMPHONY's applications, you must first compile the 
application specific library. Type

   ./configure --with-applications
   make 
   make install

This will create the application library called 'libSymAppl' to be used while 
building custom applications.

2. Go to SYMPHONY/Applications/Appl-Pckg directory and type 'make' there. 
For more information, see the INSTALL file of the corresponding application. 

******************************************************************************
*      COMPILING The SYMPHONY Library and Executable (Microsoft Windows)     *
******************************************************************************

Here is a sketch outline of how to compile SYMPHONY in Microsoft Windows.
These instructions will lead you through the steps required to compile
SYMPHONY as a generic MILP solver. This process will create (1) a generic
callable library that allows SYMPHONY to be called from an application and (2)
an executable that can be used as a stand-alone application to solve MILPs
written in either MPS or GMPL file format. SYMPHONY can be further customized
by implementing one of more than 50 callback functions that change SYMPHONY's
default execution of its algorithm. For information on customizing SYMPHONY
using callbacks, a quick start guide is provided below. Direct support
is provided for compilation under MS Visual Studio 6.0. Compilation for other
compilers should also be possible. Note that the Windows version has some
limitations. Detailed timing information is not currently provided.  Support
is only provided for running in sequential mode at this time.

First, download SYMPHONY and unpack the archive. You now have three options. 
You can either compile on the command-line using automated MSDEV 
build system or NMAKE utility or you can use the provided projects and 
workspaces. 

************************ Using MSDEV Utility *********************************

1. Open a command line terminal. Go to 'Win32/v6' directory and type 

   msdev symphony.dsw /make all    

This will create both the debug and release versions of SYMPHONY. If you 
want to compile only one of them, type 
 
   msdev symphony.dsw /make "all - debug" 

or 

   msdev symphony.dsw /make "all - release" 

For each command, the library 'libSymphony.lib' and the executable 
'symphony' will be created in 'Debug' and/or 'Release' directories.  The 
library, together with the header files in 'SYMPHONY\include\', can then be 
used to call SYMPHONY from any C/C++ code. The API for calling SYMPHONY is 
described in the user's manual.

5. To test the executable, type 

   Debug/symphony.exe -F ..\..\SYMPHONY\Datasets\sample.mps

If you want to use the interactive optimizer, simply type  

   Debug/symphony.exe

and then type "help" or "?" to see a list of available commands.
 

2. If SYMPHONY is modified, type 

   msdev symphony.dsw /make all /rebuild

in order to clean and rebuild everything. 

******************** Using the NMAKE Utility *********************************

1.  Go to 'Win32/v6' directory and edit the 'sym.mak' makefile to reflect 
your environment. This involves specifying the LP solver to be used, 
assigning some variables and  setting various paths. Only minor edits 
should be required. An explanation of what has to be set is contained in the 
comments in the makefile.

2. Once configuration is done, type 

   nmake /f sym.mak

This will make the SYMPHONY library 'libSymphony.lib' and the executable 
'symphony' in 'Debug' directory. The library, together with the header files 
in 'SYMPHONY\include\', can then be used to call SYMPHONY from any C/C++ code. 
The API for calling SYMPHONY is described in the user's manual.

3. To test the executable, type 

   Debug\symphony.exe -F ..\..\SYMPHONY\Datasets\sample.mps

If you want to use the interactive optimizer, simply type  

   symphony.exe 

and then type "help" or "?" to see a list of available commands.
 
******************** Using the MSVC++ Workspace ******************************

1. Go to 'Win32/v6' directory and open the workspace 'symphony.dsw'. 

2. Note that there are a number of additional preprocessor definitions that
control the functionality of SYMPHONY. These definitions are described in
"sym.mak", a Unix-style makefile included in the distribution. To 
enable the functionality associated with a particular definition, simply add 
it to the list of definitions of "libSymphony" project. Also note that, 
currently, only CLP lp solver is maintained.  

2. Choose "Build symphony.exe" from the Build menu. This should successfully 
build the SYMPHONY library and the corresponding executable.

3. To test the executable, right click on the symphony project, go to the
"Debug" tab and set the program arguments to 
"-F ..\..\SYMPHONY\Datasets\sample.mps". 
Note that command-line switches are Unix-style. If you want to use the 
interactive optimizer, leave this tab empty. 

4. Now choose "Execute" from the build menu and the solver should solve the
given sample problem. If you have not specified the sample problem, then 
the interactive optimizer should start. In this case, type "help" or "?" to 
see a list of available commands

Note that there is some functionality missing from the Windows version. Most
prominently, the timing functions do not work. This functionality should be
easy to add -- let me know if you are interested in doing it and I will give
you all the help I can. In addition, the Windows version will only run in
sequential mode for a variety of reasons. However, it should be relatively
easy to get it running in parallel if you can get PVM working under
Windows. Let me know if you are interested.
